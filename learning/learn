작은 컴포넌트로부터 사용자 인터페이스를 구축하는 접근 방식을 일반적으로 컴포지션(합성)이라고 부름

파일 정리
> 특정 기능을 가진 컴포넌트 폴더링
> 사용자 인터페이스를 위한 폴더

---

모든 이벤트는 dom 동작에 기반한다.

---

리액트가 jsx를 전달하고 검토하고 화면에 띄우는 방법

평범한 변수를 생성하고 이벤트 등으로 변수를 바꿔도 화면에는 변화가 없음
컴포넌트는 함수형임. 함수의 특별한 점은 jsx 코드를 반환한다는 점임.
그래서 화면을 바꾸려면 함수를 다시 호출해야 함. 

V--------------------

SSSSSSSSSSTATE

react에서는 컴포넌트(<Compo>)를 함수로 인식함.
리액트는 jsx를 평가할 때마다 컴포넌트 함수를 호출.
그리고 호출된 컴포넌트 함수들은 평가된 jsx코드를 반환함 (평가할 jsx코드가 없을 때까지)
리액트는 jsx에서 마주치는 컴포넌트 함수들을 계속해서 호출하고 함수가 반환하는 함수들을 호출함. (함수가 남아있지 않을 때까지) 

전반적인 결과를 평가하고 dom 명령어를 통해 화면에 렌더링함.(index.js부터 시작) 
리액트는 이걸 반복하지 않음 렌더링 될 때 위의 모든 과정을 실행하면 끝임.

---

setState함수가 사용되면 useState로 생성된 컴포넌트가 재평가 되어야 한다고 리액트에게 전달함.

---

컴포넌트별 인스턴스를 기반으로 독립적인 state를 가짐

---

리액트는 처음 실행될 때 useState의 인자로 초기화하고
컴포넌트가 재실행되면 상태가 변했기 때문에, 
리액트는 state를 다시 초기화하지 않음.
대신 이전에 상태가 초기화됐던 것(state가 업데이트 됐던 내역)을 추적해서 최신의 state를 제공

state의 초기값 > 처음 컴포넌트가 실행될 때만 고려됨 

---

응용프로그램에게 반응성을 추가하는 것이 state임
사용자 입력 등 여러 이벤트에 반응하고 사용자와 상호작용할 수 있게 해줌

V--------------------

커스텀 컴포넌트가 자기 자신이 아닌 부모 컴포넌트에서 제어될 때
그 자식 컴포넌트는 제어된 컴포넌트라고 한다.

----

프리젠테이셔널 vs 상태 유지 컴포넌트

컴포넌트가 state를 관리하는지 안하는지로 나뉨. 
관리하지 않는 경우, stateless component / dumb component / presentational

----

새로운 배열을 생성할 때 key를 적용하지 않으면 매번 배열을 업데이트해서 배열을 재배치하게 됨.
모든 항목을 체크하고 업데이트해야 하기 때문에 성능 측면에서 좋지 않음. (버그가 생길수도 있음.)

리액트가 왜 이렇게 작동하는가?
리액트는 배열의 아이템의 차이점을 알 수 없기 떄문에 새로운 요소가 어디에 추가되어야 할 지 판단하기 어려움.

key prop  